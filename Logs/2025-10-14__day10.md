I mainly cleaned up the remaining "hacks" ie where I used lambdas to do tasks. These are now proper Blocks.

Variables are practically complete with all math operations and conditional checks.

I think the biggest headache from here on is the event handler (When) where we often deal with context that we likely want to use in the action blocks that follow. For instance collision provides us with the "other" object and we may want to do something like DestroyOther(). Or for Input, if we receive an "OnMove" event we want to be able to apply the Vector2 to some velocity.

It's not so much about passing on this data but finding a way where the same action can act upon the current (owning) object but also act on the "other" object without having to provide many specialized blocks like DestroySelf() and DestroyOther(). Or something like AddLinearVelocity(value) where the value may be a constant or provided by the OnMove event.

One option might be to use a static type, relying on the fact that by default every script runs on the main thread. This would be just like Unity's Event.current. Then we could write:

When(InputAction("OnMove"), AddLinearVelocity(InputAction.Vector2))
When(CollisionEnter("cube"), Destroy(CollisionEnter.OtherObject))


Another thing I don't quite fancy, but this is for later:

    // add 'power of three' times the progress to score
    SetVariable(Variables["temp"], progressVar),
    MultiplyVariable(Variables["temp"], progressVar),
    MultiplyVariable(Variables["temp"], progressVar),
    AddVariable(scoreVariable, Variables["temp"]));

This should be as simple as:

    AddVariable(scoreVariable, progressVar * progressVar * progressVar));

But this won't work because this will run once on start, making those progressVar values constant when this block runs. We could certainly add progress three times, but not multiply as that would multiply by the current score. We also can't multiply progress without affecting it, unless the var is assigned to a temporary variable.
