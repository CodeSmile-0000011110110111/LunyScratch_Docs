# Day 14b

Let's consider this the second half of day 14. It felt like I did more but hours-wise, it wasn't.

I struggled a bit with Unreal until some forum post made it click: we have actors, sure. But then there's Pawns, Characters, PlayerControllers (not visible), Game Mode (huh?) and all of them work together in a certain way, or build upon each other. And as always, there's a confusing number of ways to set up a controllable player character and a follow camera.

Unreal kind of sits in-between chairs. It does have an inheritance-based OOP structure like Godot, but with a much more reasonable (shallow) depth. While it also supports components like Unity, except many components serve special purposes (scene, actor, primitive) and they are not all compatible with every kind of base class.

All the more reason to further abstract the lifecycle. Rather than subclass one, or likely several, engine base classes any kind of actor/node should register itself with a central lifecycle manager. For these overarching types there's good solutions in every engine, and it provides full flexibility for capturing and forwarding events sent to nodes/actors/components.

Having this Lifecyle management in the Core will also enhance how much code is portable. While providing both an automated and controlled way of instantiating game objects:

- Autocreate ScratchScript subclasses based on the target's name or path in the hierarchy
- Use of engine-specific components / classes which instantiate the ScratchScript - while the user can hold on to the reference, it will be disposed of by the core lifecycle management with corresponding OnBeforeDestroy event.
 

Another decision:

I will aim for more technical jargon. While PlaySound works best for entry-level programmers, we can be certain that anyone willing to step up they can and should adapt anyway to the engine-jargon, so Audio.Play seems much more reasonable and more likely to get buy-in from advanced developers.

The separation into "base" features also helps separation and modularity. Input.Something, Physics.Something, and so forth. Otherwise the API will eventually have to restort to weird conventions to avoid polluting the namespace. While one could import a static using of Input to continue to use IsKeyPressed without the prefix (at least in C#).
